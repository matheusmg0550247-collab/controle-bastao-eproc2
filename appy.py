import streamlit as st
import pandas as pd
import requests
import time
import json
import os
from datetime import datetime, timedelta
from operator import itemgetter
from streamlit_autorefresh import st_autorefresh



# --- 2. Defini√ß√£o das Vari√°veis Globais ---

# üõë WEBHOOK DE RELAT√ìRIO DI√ÅRIO (DESABILITADO)
GOOGLE_CHAT_WEBHOOK_RELATORIO = ""


# ‚¨áÔ∏è WEBHOOK DE NOTIFICA√á√ÉO IMEDIATA (DESABILITADO)
CHAT_WEBHOOK_BASTAO = ""


BASTAO_EMOJI = "üå∏"
APP_URL_CLOUD = 'https://controle-bastao-cesupe.streamlit.app' 
CONSULTORES = sorted([ # Mant√©m a lista original ordenada para consist√™ncia
    "Barbara", "Bruno", "Claudia", "Douglas", "F√°bio", "Glayce", "Isac",
    "Isabela", "Ivana", "Leonardo", "Mor√¥ni", "Michael", "Pablo", "Ranyer",
    "Victoria"
])



# --- 4. C√ìDIGO DO APP STREAMLIT (app.py) ---

def generate_app_code(consultores, emoji, webhook_relatorio, webhook_bastao, public_url):
    
    warning_gif_url = 'https://media0.giphy.com/media/v1.Y2lkPTc5MGI3NjExY2pjMDN0NGlvdXp1aHZ1ejJqMnY5MG1yZmN0d3NqcDl1bTU1dDJrciZlcD12MV9pbnRlcm5uYWxfZ2lmX2J5X2lkJmN0PWc/fXnRObM8Q0RkOmR5nf/giphy.gif'
    rotation_gif_url = 'https://media0.giphy.com/media/v1.Y2lkPTc5MGI3NjExdmx4azVxbGt4Mnk1cjMzZm5sMmp1YThteGJsMzcyYmhsdmFoczV0aSZlcD12MV9pbnRlcm5uYWxfZ2lmX2J5X2lkJmN0PWc/JpkZEKWY0s9QI4DGvF/giphy.gif'
    sound_url = "https://github.com/matheusmg0550247-collab/controle-bastao-eproc2/raw/refs/heads/main/doorbell-223669.mp3"
    
    app_code_lines = [
        "import streamlit as st",
        "import pandas as pd",
        "import requests",
        "import time",
        "import json",
        "import os",
        "from datetime import datetime, timedelta",
        "from operator import itemgetter",
        "from streamlit_autorefresh import st_autorefresh",
        "",
        f"BASTAO_EMOJI = '{emoji}'",
        f"CONSULTORES = {consultores}",
        f"WEBHOOK_RELATORIO = '{webhook_relatorio}'", 
        f"WEBHOOK_BASTAO = '{webhook_bastao}'",
        f"APP_URL = '{public_url}'",
        "TIMER_RERUN_S = 30",
        "LOG_FILE = 'status_log.json'",
        "STATE_FILE = 'app_state.json'",
        "STATUS_SAIDA_PRIORIDADE = ['Sa√≠da Tempor√°ria']",
        "STATUSES_DE_SAIDA = ['Atividade', 'Almo√ßo', 'Sa√≠da Tempor√°ria']",
        f"GIF_URL_WARNING = '{warning_gif_url}'",
        f"GIF_URL_ROTATION = '{rotation_gif_url}'",
        f"SOUND_URL = '{sound_url}'",
        "",
        "# --- Fun√ß√µes de Persist√™ncia de Estado ---",
        "",
        "def date_serializer(obj):",
        "    if isinstance(obj, datetime):",
        "        return obj.isoformat()",
        "    return str(obj)",
        "",
        "def save_state():",
        "    state_to_save = {",
        "        'status_texto': st.session_state.status_texto,",
        "        'bastao_queue': st.session_state.bastao_queue,",
        "        'bastao_start_time': st.session_state.bastao_start_time,",
        "        'current_status_starts': st.session_state.current_status_starts,",
        "        'report_last_run_date': st.session_state.report_last_run_date,",
        "        'bastao_counts': st.session_state.bastao_counts,",
        "        'priority_return_queue': st.session_state.priority_return_queue,",
        "        'rotation_gif_start_time': st.session_state.get('rotation_gif_start_time'),",
        # --- ‚¨áÔ∏è MUDAN√áA AQUI (Nova L√≥gica) ‚¨áÔ∏è ---
        "        'master_order': st.session_state.master_order, # Persiste a ordem mestre",
        # 'skipped_this_lap' e 'completed_this_lap' N√ÉO s√£o persistidos
        # --- ‚¨ÜÔ∏è MUDAN√áA AQUI ‚¨ÜÔ∏è ---
        "    }",
        "    try:",
        "        with open(STATE_FILE, 'w') as f:",
        "            json.dump(state_to_save, f, indent=4, default=date_serializer)",
        "    except Exception as e:",
        "        print(f'Erro ao salvar estado: {e}')",
        "",
        "def load_state():",
        "    if os.path.exists(STATE_FILE):",
        "        try:",
        "            with open(STATE_FILE, 'r') as f:",
        "                data = json.load(f)",
        "            ",
        "            for key in ['bastao_start_time', 'report_last_run_date']:",
        "                if data.get(key) and isinstance(data[key], str):",
        "                   try: data[key] = datetime.fromisoformat(data[key])",
        "                   except ValueError: data[key] = None",
        "            if 'current_status_starts' in data:",
        "                temp_starts = {}",
        "                for consultor, time_str in data['current_status_starts'].items():",
        "                    if time_str and isinstance(time_str, str):",
        "                        try: temp_starts[consultor] = datetime.fromisoformat(time_str)",
        "                        except ValueError: temp_starts[consultor] = datetime.now()",
        "                    else: temp_starts[consultor] = datetime.now() # Default if missing/invalid",
        "                data['current_status_starts'] = temp_starts",
        "            ",
        "            if 'rotation_gif_start_time' in data and data.get('rotation_gif_start_time') and isinstance(data['rotation_gif_start_time'], str):",
        "                try: data['rotation_gif_start_time'] = datetime.fromisoformat(data['rotation_gif_start_time'])",
        "                except ValueError: data['rotation_gif_start_time'] = None",
        "            ",
        "            # Garante que master_order existe e √© uma lista",
        "            if 'master_order' not in data or not isinstance(data['master_order'], list):",
        "                data['master_order'] = [] # Ou inicializa com CONSULTORES se preferir",
        "",
        "            return data",
        "        except (FileNotFoundError, json.JSONDecodeError, KeyError, TypeError) as e:",
        "            print(f'Erro ao carregar estado: {e}. Iniciando estado padr√£o.')",
        "            return {}",
        "    return {}",
        "",
        "# --- Fun√ß√µes de Log e Notifica√ß√£o ---",
        "",
        "def send_chat_notification_internal(consultor, status):",
        "    if WEBHOOK_BASTAO and status == 'Bast√£o':",
        '        message_template = "üéâ **BAST√ÉO GIRADO!** üéâ \\n\\n- **Novo Respons√°vel:** {consultor}\\n- **Acesse o Painel:** https://controle-bastao-eproc.streamlit.app/" ',
        '        message_text = message_template.format(consultor=consultor, app_url=APP_URL)',
        '        chat_message = {"text": message_text}',
        '        try:',
        '            response = requests.post(WEBHOOK_BASTAO, json=chat_message)',
        '            response.raise_for_status()',
        '            return True',
        '        except requests.exceptions.RequestException as e: ',
        '            print(f"Erro ao enviar notifica√ß√£o: {e}")',
        '            return False',
        '    return False',
        "",
        "def play_sound_html():",
        '    return f"""',
        '<audio autoplay="true">',
        '        <source src="{SOUND_URL}" type="audio/mpeg">',
        '        Seu navegador n√£o suporta o elemento de √°udio.',
        '</audio>',
        '"""',
        "",
        "def load_logs():",
        "    try:",
        "        with open(LOG_FILE, 'r') as f:",
        "            return json.load(f)",
        "    except (FileNotFoundError, json.JSONDecodeError):",
        "        return []",
        "def save_logs(logs):\n",
        "    with open(LOG_FILE, 'w') as f: json.dump(logs, f, indent=4, default=date_serializer)",
        "def log_status_change(consultor, old_status, new_status, duration):",
        "    logs = load_logs()",
        "    start_time = st.session_state['current_status_starts'].get(consultor, datetime.now()) # Use existing start time if available",
        "    log_entry = {",
        "        'consultor': consultor,",
        "        'old_status': old_status if old_status else 'Dispon√≠vel',",
        "        'new_status': new_status if new_status else 'Dispon√≠vel',",
        "        'duration_s': duration.total_seconds() if isinstance(duration, timedelta) else 0,",
        "        'start_time': start_time.isoformat(), # Log the start time of the previous status",
        "        'end_time': datetime.now().isoformat() # Log the time the status changed",
        "    }",
        "    logs.append(log_entry)",
        "    save_logs(logs)",
        "    st.session_state['current_status_starts'][consultor] = datetime.now() # Set start time for the NEW status",
        "    save_state()",
        "",
        "def format_time_duration(duration):",
        "    total_seconds = int(duration.total_seconds())",
        "    hours = total_seconds // 3600",
        "    minutes = (total_seconds % 3600) // 60",
        "    seconds = total_seconds % 60",
        "    return f'{hours:02}:{minutes:02}:{seconds:02}'",
        "",
        "def send_daily_report():",
        "    logs = load_logs()",
        "    today_str = datetime.now().date().isoformat()",
        "    report_data = [log for log in logs if log.get('start_time', '').startswith(today_str)]",
        "    ",
        "    if not report_data or not WEBHOOK_RELATORIO:",
        "        st.session_state['report_last_run_date'] = datetime.now()",
        "        save_state()",
        "        return",
        "    ",
        "    # Simplified statuses for report",
        "    TRACKED_STATUSES_REPORT = ['Bast√£o', 'Atividade', 'Almo√ßo', 'Sa√≠da Tempor√°ria']",
        "    summary = {consultor: {status: timedelta() for status in TRACKED_STATUSES_REPORT} for consultor in CONSULTORES}",
        "    counts = {consultor: {status: 0 for status in TRACKED_STATUSES_REPORT} for consultor in CONSULTORES}",
        "",
        "    for log in report_data:",
        "        consultor = log['consultor']",
        "        status = log['old_status'] # Track duration of the PREVIOUS status",
        "        duration_s = log.get('duration_s', 0)",
        "        if consultor in summary and status in summary[consultor]:",
        "            summary[consultor][status] += timedelta(seconds=duration_s)",
        "            counts[consultor][status] += 1",
        "",
        "    report_text = f'üìä **RELAT√ìRIO DI√ÅRIO DE BAST√ÉO - {today_str}**\\n\\n'",
        "",
        "    # Sort by total time with baton",
        "    bastao_ranking = sorted(CONSULTORES, key=lambda c: summary[c]['Bast√£o'], reverse=True)",
        "",
        "    for consultor in bastao_ranking:",
        "        has_data = any(summary[consultor][status] > timedelta(0) for status in TRACKED_STATUSES_REPORT)",
        "        if not has_data: continue # Skip if no activity",
        "        report_text += f'**--- {consultor} ---**\\n'",
        "        for status in TRACKED_STATUSES_REPORT:",
        "            if summary[consultor][status] > timedelta(0):",
        "                duration_str = format_time_duration(summary[consultor][status])",
        "                count = counts[consultor][status]",
        "                report_text += f'- *{status}*: {count}x ({duration_str})\\n'",
        "        report_text += '\\n'",
        "",
        "    chat_message = {'text': report_text}", # Simplified message for now
        "",
        "    try:",
        "        response = requests.post(WEBHOOK_RELATORIO, json=chat_message)",
        "        response.raise_for_status()",
        "        st.session_state['report_last_run_date'] = datetime.now()",
        "        save_state()",
        "    except requests.exceptions.RequestException as e:",
        "        print(f'Erro ao enviar relat√≥rio: {e}')",
        "    st.rerun()",
        "",
        "# --- Inicializa√ß√£o do Session State ---",
        "",
        "def init_session_state():",
        "    persisted_state = load_state()",
        "    ",
        "    default_datetime = datetime.now()",
        "    default_date_min = datetime.min",
        "    ",
        "    st.session_state.setdefault('status_texto', persisted_state.get('status_texto', {nome: '' for nome in CONSULTORES}))",
        "    st.session_state.setdefault('bastao_queue', persisted_state.get('bastao_queue', []))",
        "    st.session_state.setdefault('bastao_start_time', persisted_state.get('bastao_start_time', None))",
        "    st.session_state.setdefault('current_status_starts', persisted_state.get('current_status_starts', {nome: default_datetime for nome in CONSULTORES}))",
        "    st.session_state.setdefault('report_last_run_date', persisted_state.get('report_last_run_date', default_date_min))",
        "    st.session_state.setdefault('bastao_counts', persisted_state.get('bastao_counts', {nome: 0 for nome in CONSULTORES}))",
        "    st.session_state.setdefault('priority_return_queue', persisted_state.get('priority_return_queue', []))",
        "    st.session_state.setdefault('rotation_gif_start_time', persisted_state.get('rotation_gif_start_time', None))",
        "",
        "    # --- ‚¨áÔ∏è MUDAN√áA AQUI (Nova L√≥gica) ‚¨áÔ∏è ---",
        "    st.session_state.setdefault('master_order', persisted_state.get('master_order', []))",
        "    st.session_state.setdefault('completed_this_lap', set()) # Always reset on load",
        "    st.session_state.setdefault('skipped_this_lap', set())   # Always reset on load",
        "    # --- ‚¨ÜÔ∏è MUDAN√áA AQUI ‚¨ÜÔ∏è ---",
        "",
        "    for nome in CONSULTORES:",
        "        checkbox_key = f'check_{nome}'",
        "        st.session_state.setdefault(checkbox_key, nome in st.session_state['bastao_queue'] or nome in st.session_state.get('skipped_this_lap', set()))",
        "",
        "    # Ensure all current consultants have a start time entry",
        "    for nome in CONSULTORES:",
        "        if nome not in st.session_state['current_status_starts']:",
        "            st.session_state['current_status_starts'][nome] = default_datetime",
        "",
        "    if not os.path.exists(STATE_FILE):",
        "        save_state()",
        "",
        # --- ‚¨áÔ∏è MUDAN√áA AQUI (Nova L√≥gica) ‚¨áÔ∏è ---
        "# --- Nova Fun√ß√£o: Reset de Ciclo ---",
        "def check_cycle_reset():",
        "    available_in_master = set()",
        "    for consultor in st.session_state.get('master_order', []):",
        "        if st.session_state.get(f'check_{consultor}', False):",
        "             available_in_master.add(consultor)",
        "",
        "    completed = st.session_state.get('completed_this_lap', set())",
        "",
        "    # Check if everyone available has completed (and the set is not empty)",
        "    if available_in_master and completed and available_in_master.issubset(completed):",
        "        print('--- RESETANDO CICLO ---')",
        "        st.session_state['completed_this_lap'] = set()",
        "        st.session_state['skipped_this_lap'] = set()",
        "",
        "        # Rebuild bastao_queue based on master_order for available consultants",
        "        new_bastao_queue = []",
        "        for consultor in st.session_state.get('master_order', []):",
        "            if st.session_state.get(f'check_{consultor}', False):",
        "                new_bastao_queue.append(consultor)",
        "        st.session_state['bastao_queue'] = new_bastao_queue",
        "        print(f'Nova Fila: {new_bastao_queue}')",
        "        # N√£o chama check_and_assume_baton aqui, deixa a a√ß√£o principal chamar",
        "        return True",
        "    return False",
        # --- ‚¨ÜÔ∏è MUDAN√áA AQUI ‚¨ÜÔ∏è ---
        "",
        "# --- L√≥gica Principal (Callbacks) ---",
        "",
        "def manual_rerun():", 
        "    st.session_state['gif_warning'] = False ", 
        "    st.session_state['rotation_gif_start_time'] = None",
        "    st.rerun()", 
        "    ",
        "# --- ‚¨áÔ∏è MUDAN√áA AQUI (Nova L√≥gica) ‚¨áÔ∏è ---",
        "def check_and_assume_baton():",
        "    current_holder = st.session_state['bastao_queue'][0] if st.session_state['bastao_queue'] else None",
        "    current_status_holder = st.session_state['status_texto'].get(current_holder, '') if current_holder else ''",
        "",
        "    # If current holder already has baton status, do nothing",
        "    if current_holder and current_status_holder == 'Bast√£o':",
        "        return",
        "",
        "    # Find the next eligible person in the queue",
        "    next_holder = None",
        "    for consultor in st.session_state['bastao_queue']:",
        "        if consultor not in st.session_state.get('skipped_this_lap', set()) and st.session_state.get(f'check_{consultor}', False):",
        "            next_holder = consultor",
        "            break",
        "",
        "    # Clear baton from everyone else",
        "    for c in CONSULTORES:",
        "        if c != next_holder and st.session_state['status_texto'].get(c) == 'Bast√£o':",
        "            old_status = 'Bast√£o'",
        "            duration = datetime.now() - st.session_state['current_status_starts'].get(c, datetime.now())",
        "            log_status_change(c, old_status, '', duration)", # Log leaving baton
        "            st.session_state['status_texto'][c] = ''",
        "",
        "    # Assign baton to the next holder if found",
        "    if next_holder:",
        "        if st.session_state['status_texto'].get(next_holder) != 'Bast√£o':",
        "            old_status = st.session_state['status_texto'].get(next_holder, '')",
        "            duration = datetime.now() - st.session_state['current_status_starts'].get(next_holder, datetime.now())",
        "            log_status_change(next_holder, old_status, 'Bast√£o', duration) # Log getting baton",
        "            st.session_state['status_texto'][next_holder] = 'Bast√£o'",
        "            st.session_state['bastao_start_time'] = datetime.now()",
        "            # Play sound only if baton changed hands to someone new",
        "            if current_holder != next_holder:",
        "                st.session_state['play_sound'] = True",
        "                send_chat_notification_internal(next_holder, 'Bast√£o')",
        "    else:",
        "        # No eligible person found, clear start time",
        "        st.session_state['bastao_start_time'] = None",
        "",
        "    save_state()",
        # No rerun here, let the calling function handle it
        # --- ‚¨ÜÔ∏è MUDAN√áA AQUI ‚¨ÜÔ∏è ---
        "",
        "# --- ‚¨áÔ∏è MUDAN√áA AQUI (Nova L√≥gica) ‚¨áÔ∏è ---",
        "def update_queue(consultor):\n",
        "    st.session_state['gif_warning'] = False \n",
        "    st.session_state['rotation_gif_start_time'] = None",
        "    checkbox_key = f'check_{consultor}'\n",
        "    is_checked = st.session_state.get(checkbox_key, False)\n",
        "    old_status = st.session_state['status_texto'].get(consultor, '') or 'Dispon√≠vel'\n",
        "    duration = datetime.now() - st.session_state['current_status_starts'].get(consultor, datetime.now())\n",
        "",
        "    was_holder = consultor == (st.session_state['bastao_queue'][0] if st.session_state['bastao_queue'] else None)",
        "",
        "    if is_checked: # User is marking as AVAILABLE",
        "        log_status_change(consultor, old_status, 'Dispon√≠vel na Fila', duration)\n",
        "        st.session_state['status_texto'][consultor] = '' # Clear specific status",
        "",
        "        # Add to master order if not present",
        "        if consultor not in st.session_state.get('master_order', []):",
        "            st.session_state.setdefault('master_order', []).append(consultor)",
        "",
        "        # Add to end of active queue if not already there",
        "        if consultor not in st.session_state.get('bastao_queue', []):",
        "            st.session_state.setdefault('bastao_queue', []).append(consultor)",
        "",
        "        # Ensure they are not marked as skipped for the new potential cycle",
        "        st.session_state.setdefault('skipped_this_lap', set()).discard(consultor)",
        "        # Completed status will be handled by rotation or skipping",
        "",
        "        # Check if cycle resets (might happen if this was the last person needed)",
        "        cycle_reset = check_cycle_reset()",
        "        check_and_assume_baton() # Assign baton if queue was empty or changed",
        "",
        "    else: # User is marking as UNAVAILABLE",
        "        log_status_change(consultor, old_status, 'Indispon√≠vel', duration)\n",
        "        st.session_state['status_texto'][consultor] = '' # Clear specific status",
        "",
        "        # Remove from active queue",
        "        if consultor in st.session_state.get('bastao_queue', []):",
        "            st.session_state['bastao_queue'].remove(consultor)",
        "",
        "        # Remove from tracking sets for the current lap",
        "        st.session_state.setdefault('skipped_this_lap', set()).discard(consultor)",
        "        st.session_state.setdefault('completed_this_lap', set()).discard(consultor)",
        "",
        "        # DO NOT remove from master_order",
        "",
        "        # Check if cycle resets because the set of available people changed",
        "        cycle_reset = check_cycle_reset()",
        "        if was_holder or cycle_reset:",
        "             check_and_assume_baton() # Reassign baton if holder left or cycle reset",
        "",
        "    save_state()\n",
        "    st.rerun()\n",
        # --- ‚¨ÜÔ∏è MUDAN√áA AQUI ‚¨ÜÔ∏è ---
        "",
        "# --- ‚¨áÔ∏è MUDAN√áA AQUI (Nova L√≥gica) ‚¨áÔ∏è ---",
        "def rotate_bastao():\n",
        "    selected_name = st.session_state.get('consultor_selectbox', 'Selecione um nome')\n",
        "    st.session_state['gif_warning'] = False \n",
        "    st.session_state['rotation_gif_start_time'] = None # Assume failure first",
        "",
        "    if selected_name == 'Selecione um nome' or not selected_name:",
        "        st.warning('Selecione um consultor.')",
        "        return",
        "",
        "    queue = st.session_state.get('bastao_queue', [])",
        "    if not queue or selected_name != queue[0]:",
        "        st.session_state['gif_warning'] = True",
        "        st.rerun()",
        "        return",
        "",
        "    # Proceed with rotation",
        "    holder = queue.pop(0)",
        "    queue.append(holder)",
        "    st.session_state['bastao_queue'] = queue",
        "",
        "    # Log and update state",
        "    old_status = 'Bast√£o'",
        "    duration = datetime.now() - st.session_state.get('bastao_start_time', datetime.now())",
        "    log_status_change(holder, old_status, 'Dispon√≠vel na Fila', duration)", # Log duration",
        "    st.session_state['status_texto'][holder] = '' # Clear holder's status text",
        "    st.session_state['bastao_counts'][holder] = st.session_state['bastao_counts'].get(holder, 0) + 1",
        "    st.session_state['play_sound'] = True",
        "    st.session_state['rotation_gif_start_time'] = datetime.now()",
        "",
        "    # Mark as completed",
        "    st.session_state.setdefault('completed_this_lap', set()).add(holder)",
        "",
        "    # Check for cycle reset BEFORE assigning new baton",
        "    cycle_reset = check_cycle_reset()",
        "    check_and_assume_baton()",
        "",
        "    save_state()",
        "    st.rerun()\n",
        # --- ‚¨ÜÔ∏è MUDAN√áA AQUI ‚¨ÜÔ∏è ---
        "",
        "# --- ‚¨áÔ∏è MUDAN√áA AQUI (Nova L√≥gica) ‚¨áÔ∏è ---",
        "def skip_turn():\n",
        "    st.session_state['gif_warning'] = False \n",
        "    st.session_state['rotation_gif_start_time'] = None",
        "    selected_name = st.session_state.get('consultor_selectbox', 'Selecione um nome')\n",
        "",
        "    if selected_name == 'Selecione um nome' or not selected_name:",
        "        st.warning('Selecione um consultor.')",
        "        return",
        "",
        "    queue = st.session_state.get('bastao_queue', [])",
        "    if selected_name not in queue:",
        "        st.warning(f'{selected_name} n√£o est√° na fila ativa para pular.')",
        "        return",
        "",
        "    # Proceed with skipping",
        "    is_holder = (selected_name == queue[0]) if queue else False",
        "    queue.remove(selected_name)",
        "    st.session_state['bastao_queue'] = queue",
        "",
        "    # Log and update state",
        "    old_status = 'Bast√£o' if is_holder else st.session_state['status_texto'].get(selected_name, '') or 'Dispon√≠vel'",
        "    duration = datetime.now() - st.session_state['current_status_starts'].get(selected_name, datetime.now())",
        "    log_status_change(selected_name, old_status, 'Pulou Turno', duration)",
        "    st.session_state['status_texto'][selected_name] = '' # Clear specific status",
        "",
        "    # Add to tracking sets",
        "    st.session_state.setdefault('skipped_this_lap', set()).add(selected_name)",
        "    st.session_state.setdefault('completed_this_lap', set()).add(selected_name)",
        "",
        "    # Check for cycle reset BEFORE assigning baton",
        "    cycle_reset = check_cycle_reset()",
        "    if is_holder or cycle_reset:",
        "        check_and_assume_baton()",
        "",
        "    save_state()\n",
        "    st.rerun()\n",
        # --- ‚¨ÜÔ∏è MUDAN√áA AQUI ‚¨ÜÔ∏è ---
        "",
        "# --- ‚¨áÔ∏è MUDAN√áA AQUI (Nova L√≥gica) ‚¨áÔ∏è ---",
        "def update_status(status_text, change_to_available):\n",
        "    selected_name = st.session_state.get('consultor_selectbox', 'Selecione um nome')\n",
        "    st.session_state['gif_warning'] = False \n",
        "    st.session_state['rotation_gif_start_time'] = None",
        "",
        "    if selected_name == 'Selecione um nome' or not selected_name:",
        "        st.warning('Selecione um consultor.')",
        "        return",
        "",
        "    if selected_name not in st.session_state['status_texto']:",
        "        return # Should not happen",
        "",
        "    # Mark as unavailable",
        "    st.session_state[f'check_{selected_name}'] = False",
        "",
        "    is_holder = selected_name == (st.session_state['bastao_queue'][0] if st.session_state['bastao_queue'] else None)",
        "    old_status = st.session_state['status_texto'].get(selected_name, '') or ('Bast√£o' if is_holder else 'Dispon√≠vel')",
        "    duration = datetime.now() - st.session_state['current_status_starts'].get(selected_name, datetime.now())",
        "    log_status_change(selected_name, old_status, status_text, duration)",
        "",
        "    st.session_state['status_texto'][selected_name] = status_text",
        "",
        "    # Remove from active queue and tracking sets",
        "    if selected_name in st.session_state.get('bastao_queue', []):",
        "        st.session_state['bastao_queue'].remove(selected_name)",
        "    st.session_state.setdefault('skipped_this_lap', set()).discard(selected_name)",
        "    st.session_state.setdefault('completed_this_lap', set()).discard(selected_name)",
        "",
        "    # Handle priority queue for 'Sa√≠da Tempor√°ria'",
        "    if status_text in STATUS_SAIDA_PRIORIDADE:",
        "        if selected_name not in st.session_state.get('priority_return_queue', []):",
        "            st.session_state.setdefault('priority_return_queue', []).append(selected_name)",
        "    elif selected_name in st.session_state.get('priority_return_queue', []):",
        "         st.session_state['priority_return_queue'].remove(selected_name)",
        "",
        "    # Check for cycle reset and baton change",
        "    cycle_reset = check_cycle_reset()",
        "    if is_holder or cycle_reset:",
        "         check_and_assume_baton()",
        "",
        "    save_state()\n",
        "    st.rerun()\n",
        # --- ‚¨ÜÔ∏è MUDAN√áA AQUI ‚¨ÜÔ∏è ---
        "",
        "# --- IN√çCIO DA APLICA√á√ÉO STREAMLIT (app.py) ---",
        "",
        "if 'gif_warning' not in st.session_state:",
        "    st.session_state['gif_warning'] = False",
        "if 'rotation_gif_start_time' not in st.session_state:",
        "    st.session_state['rotation_gif_start_time'] = None",
        "if 'play_sound' not in st.session_state:",
        "    st.session_state['play_sound'] = False",
        "if 'last_rerun_time' not in st.session_state:",
        "    st.session_state['last_rerun_time'] = datetime.now()",
        "",
        "init_session_state()", 
        "",
        "st.markdown(\"""<style>div.stAlert { display: none !important; }</style>\"\"\", unsafe_allow_html=True)",
        "",
        'st.set_page_config(page_title="Controle Bast√£o Cesupe", layout="wide")',
        "",
        "st.title(f'Controle Bast√£o Cesupe {BASTAO_EMOJI}')",
        'st.markdown("<hr style=\\"border: 1px solid #E75480;\\">", unsafe_allow_html=True)',
        "",
        "if st.session_state.get('play_sound', False):",
        "    st.components.v1.html(play_sound_html(), height=0, width=0)",
        "    st.session_state['play_sound'] = False # Reset",
        "",
        "gif_start_time = st.session_state.get('rotation_gif_start_time', None)",
        "show_gif = False",
        "refresh_interval = 30000 # Padr√£o 30s",
        "",
        "if gif_start_time:",
        "    try:",
        "        time_elapsed = (datetime.now() - gif_start_time).total_seconds()",
        "        if time_elapsed < 20:",
        "            show_gif = True",
        "            refresh_interval = 5000 # Override 5s",
        "        else:",
        "            st.session_state['rotation_gif_start_time'] = None # Limpa",
        "            show_gif = False",
        "    except TypeError:",
        "        st.session_state['rotation_gif_start_time'] = None",
        "        show_gif = False",
        "",
        "st_autorefresh(interval=refresh_interval, key='auto_rerun_key')", # Refresh √önico
        "",
        "if show_gif:",
        "    col_gif_rot, col_gif_spacer = st.columns([0.3, 0.7])",
        "    col_gif_rot.image(GIF_URL_ROTATION, width=200, caption='BAST√ÉO GIRADO!')",
        "",
        "if st.session_state['gif_warning']:",
        "    st.error('üö´ A√ß√£o inv√°lida! Verifique as regras.')",
        "    col_gif, col_spacer = st.columns([0.2, 0.8])",
        "    col_gif.image(GIF_URL_WARNING, width=150)",
        "",
        'col_principal, col_disponibilidade = st.columns([1.5, 1])',
        "",
        "# --- ‚¨áÔ∏è MUDAN√áA AQUI (Nova L√≥gica) ‚¨áÔ∏è ---",
        "# Pega dados do estado atualizado",
        "active_queue = st.session_state.get('bastao_queue', [])",
        "master = st.session_state.get('master_order', [])",
        "skipped = st.session_state.get('skipped_this_lap', set())",
        "responsavel = active_queue[0] if active_queue else ''",
        "proximo_responsavel = active_queue[1] if len(active_queue) > 1 else ''",
        "fila_restante = active_queue[2:]",
        # --- ‚¨ÜÔ∏è MUDAN√áA AQUI ‚¨ÜÔ∏è ---
        "",
        "with col_principal:",
        '    st.header("Respons√°vel pelo Bast√£o")',
        "",
        "    col_gif, col_time = st.columns([0.25, 0.75])",
        "    col_gif.image('https://media1.giphy.com/media/v1.Y2lkPTc5MGI3NjExYjlqeWg3bXpuZ2ltMXdsNXJ6OW13eWF5aXlqYnc1NGNjamFjczlpOSZlcD12MV9pbnRlcm5uYWxfZ2lmX2J5X2lkJmN0PWc/xAFPuHVjmsBmU/giphy.gif', width=50)",
        "",
        "    bastao_duration = timedelta()",
        "    if responsavel and st.session_state.get('bastao_start_time'):",
        "        start_time = st.session_state['bastao_start_time']",
        "        try: bastao_duration = datetime.now() - start_time",
        "        except: pass",
        "        duration_text = format_time_duration(bastao_duration)",
        "        col_time.markdown(f'#### üïí Tempo: **{duration_text}**')",
        "    else:",
        "        col_time.markdown('#### üïí Tempo: --:--:--')",
        "",
        "    if responsavel:",
        "        display_responsavel_html = f'<span style=\"background-color: #E75480; color: white; padding: 5px 10px; border-radius: 5px; font-size: 2em; font-weight: bold;\">üî• {responsavel}</span>'",
        "        st.markdown(display_responsavel_html, unsafe_allow_html=True)",
        "    else:",
        "        st.markdown(f'## (Ningu√©m na fila)')", # Ajuste da mensagem
        '    st.markdown("###")',
        "",
        '    st.header("Pr√≥ximos da Fila Ativa")',
        "    if proximo_responsavel:",
        "        st.markdown(f'### 1¬∫: **{proximo_responsavel}**')",
        "        if fila_restante:",
        "            st.markdown(f'#### 2¬∫ em diante: {', '.join(fila_restante)}')",
        "    else:",
        "        if responsavel: st.markdown('*Apenas o respons√°vel na fila ativa.*')",
        "        else: st.markdown('*Fila ativa vazia.*')",
        "    ",
        "    # Mostra quem pulou nesta volta",
        "    if skipped:",
        "        skipped_list_str = ', '.join(sorted(list(skipped)))",
        "        st.markdown(f'<br><span style=\"color:orange;\">üö´ Pulou nesta volta:</span> {skipped_list_str}', unsafe_allow_html=True)",
        "    ",
        '    st.markdown("###")',
        "",
        '    st.header("**Consultor**")',
        "    st.selectbox(",
        '        "Selecione o Consultor:",',
        "        options=['Selecione um nome'] + CONSULTORES,",
        "        index=0,",
        "        key='consultor_selectbox',",
        "        label_visibility='collapsed'",
        "    )",
        '    st.markdown("#### ")',
        '    st.markdown("**Mudar Status:**")',
        "",
        '    col_b1, col_b2, col_b3, col_b4, col_b5 = st.columns(5)',
        "    col_b1.button('üéØ Bast√£o', on_click=rotate_bastao, use_container_width=True, help='Passa o bast√£o para o pr√≥ximo da fila ativa. Apenas o respons√°vel atual pode fazer isso.')",
        "    col_b2.button('‚è≠Ô∏è Pular', on_click=skip_turn, use_container_width=True, help='Sai da fila ativa *nesta volta*. Volta automaticamente no pr√≥ximo ciclo. Qualquer um na fila ativa pode pular.')",
        "    col_b3.button('‚úèÔ∏è Atividade', on_click=update_status, args=('Atividade', False,), use_container_width=True)",
        "    col_b4.button('üçΩÔ∏è Almo√ßo', on_click=update_status, args=('Almo√ßo', False,), use_container_width=True)",
        "    col_b5.button('üö∂ Sa√≠da', on_click=update_status, args=('Sa√≠da Tempor√°ria', False,), use_container_width=True)",
        "",
        '    st.markdown("####")',
        "    st.button('üîÑ Atualizar (Manual)', on_click=manual_rerun, use_container_width=True)",
        '    st.markdown("---")',
        "",
        "with col_disponibilidade:",
        "    st.header('Status dos Consultores')",
        "    st.markdown('Marque/Desmarque para entrar/sair da fila ativa.')",
        "",
        "    # --- ‚¨áÔ∏è MUDAN√áA AQUI (Nova L√≥gica UI) ‚¨áÔ∏è ---",
        "    # Categoriza baseado no STATUS e Checkbox",
        "    list_na_fila_ui = []",
        "    list_atividade_ui = []",
        "    list_almoco_ui = []",
        "    list_saida_ui = []",
        "    list_indisponivel_ui = []",
        "",
        "    for nome in CONSULTORES:", # Itera por todos para garantir a exibi√ß√£o
        "        is_checked = st.session_state.get(f'check_{nome}', False)",
        "        status = st.session_state['status_texto'].get(nome, '')",
        "",
        "        if is_checked:",
        "            # Se est√° checado, pertence √† fila ou pulou",
        "            list_na_fila_ui.append(nome)",
        "        elif status == 'Atividade':",
        "            list_atividade_ui.append(nome)",
        "        elif status == 'Almo√ßo':",
        "            list_almoco_ui.append(nome)",
        "        elif status == 'Sa√≠da Tempor√°ria':",
        "            list_saida_ui.append(nome)",
        "        else: # N√£o est√° checado e sem status espec√≠fico",
        "            list_indisponivel_ui.append(nome)",
        "",
        "    # Renderiza Se√ß√£o 'Na Fila' (baseado na master_order)",
        "    st.subheader(f'‚úÖ Na Fila ({len(list_na_fila_ui)})')",
        "    if not master:",
        "         st.markdown('_Ningu√©m entrou na fila ainda._')",
        "    else:",
        "        nomes_na_fila_renderizados = 0",
        "        for nome in master:",
        "            if nome in list_na_fila_ui: # Renderiza apenas os checados, na ordem mestre",
        "                nomes_na_fila_renderizados += 1",
        "                col_nome, col_check = st.columns([0.8, 0.2])",
        "                checkbox_key = f'check_{nome}'",
        "                # Checkbox nunca √© desabilitado aqui, a l√≥gica de pular √© s√≥ visual/funcional",
        "                col_check.checkbox(' ', key=checkbox_key, on_change=update_queue, args=(nome,), label_visibility='collapsed')",
        "                ",
        "                if nome == responsavel:",
        "                    display_html = f'<span style=\"background-color: #E75480; color: white; padding: 2px 6px; border-radius: 5px; font-weight: bold;\">üî• {nome}</span>'",
        "                    col_nome.markdown(display_html, unsafe_allow_html=True)",
        "                elif nome in skipped:",
        "                    col_nome.markdown(f'**{nome}** :orange-background[Pulou]', unsafe_allow_html=True)",
        "                elif nome in active_queue:",
        "                    col_nome.markdown(f'**{nome}** :blue-background[Na Fila]', unsafe_allow_html=True)",
        "                else:",
        "                    # Estado intermitente: Checado, na master, mas n√£o na fila ativa (ex: acabou de voltar)",
        "                    # Deveria ser adicionado ao fim da fila ativa na pr√≥xima a√ß√£o ou refresh",
        "                    col_nome.markdown(f'**{nome}** :grey-background[Dispon√≠vel]', unsafe_allow_html=True)",
        "        if nomes_na_fila_renderizados == 0:",
        "             st.markdown('_Ningu√©m dispon√≠vel na fila._')",
        "",
        "    st.markdown('---')",
        "",
        "    # Renderiza Outras Se√ß√µes (Atividade, Almo√ßo, Sa√≠da, Indispon√≠vel)",
        "    def render_status_section(title, icon, names_list, tag_color):",
        "        st.subheader(f'{icon} {title} ({len(names_list)})')",
        "        if not names_list:",
        "            st.markdown(f'_Ningu√©m em {title.lower()}._')",
        "        else:",
        "            for nome in sorted(names_list): # Ordena alfabeticamente dentro da se√ß√£o",
        "                col_nome, col_check = st.columns([0.8, 0.2])",
        "                checkbox_key = f'check_{nome}'",
        "                col_check.checkbox(' ', key=checkbox_key, on_change=update_queue, args=(nome,), label_visibility='collapsed')",
        "                col_nome.markdown(f'**{nome}** :{tag_color}-background[{title}]', unsafe_allow_html=True)",
        "        st.markdown('---')",
        "",
        "    render_status_section('Atividade', '‚úèÔ∏è', list_atividade_ui, 'yellow')",
        "    render_status_section('Almo√ßo', 'üçΩÔ∏è', list_almoco_ui, 'blue')",
        "    render_status_section('Sa√≠da', 'üö∂', list_saida_ui, 'red')",
        "    render_status_section('Indispon√≠vel', '‚ùå', list_indisponivel_ui, 'grey')",
        "    # --- ‚¨ÜÔ∏è MUDAN√áA AQUI ‚¨ÜÔ∏è ---",
        "",
        "    current_hour = datetime.now().hour",
        "    today = datetime.now().date()",
        "    last_run_date = st.session_state['report_last_run_date'].date() if isinstance(st.session_state['report_last_run_date'], datetime) else datetime.min.date()",
        "    ",
        "    if current_hour >= 20 and today > last_run_date:",
        "        send_daily_report()",
        "",
        ""
    ]

    return "\n".join(app_code_lines)


# ‚¨áÔ∏è CHAME A FUN√á√ÉO generate_app_code E EXECUTE O RESULTADO
app_code_final = generate_app_code(
    CONSULTORES, 
    BASTAO_EMOJI, 
    GOOGLE_CHAT_WEBHOOK_RELATORIO, 
    CHAT_WEBHOOK_BASTAO, 
    APP_URL_CLOUD
)

# ‚¨ÖÔ∏è EXECUTA O C√ìDIGO FINAL LIMPO NO AMBIENTE STREAMLIT
exec(app_code_final)
