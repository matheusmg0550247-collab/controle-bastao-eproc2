import streamlit as st
import pandas as pd
import requests
import time
import json
import os
from datetime import datetime, timedelta
from operator import itemgetter
from streamlit_autorefresh import st_autorefresh

# --- 1. Defini√ß√µes Globais ---
# ... (Constantes como antes: CONSULTORES, URLs, etc.) ...
GOOGLE_CHAT_WEBHOOK_RELATORIO = ""
CHAT_WEBHOOK_BASTAO = ""
BASTAO_EMOJI = "üå∏"
APP_URL_CLOUD = 'https://controle-bastao-cesupe.streamlit.app'
CONSULTORES = sorted([
    "Barbara", "Bruno", "Claudia", "Douglas", "F√°bio", "Glayce", "Isac",
    "Isabela", "Ivana", "Leonardo", "Mor√¥ni", "Michael", "Pablo", "Ranyer",
    "Victoria"
])
LOG_FILE = 'status_log.json'
STATE_FILE = 'app_state.json'
STATUS_SAIDA_PRIORIDADE = ['Sa√≠da Tempor√°ria']
STATUSES_DE_SAIDA = ['Atividade', 'Almo√ßo', 'Sa√≠da Tempor√°ria']
GIF_URL_WARNING = 'https://media0.giphy.com/media/v1.Y2lkPTc5MGI3NjExY2pjMDN0NGlvdXp1aHZ1ejJqMnY5MG1yZmN0d3NqcDl1bTU1dDJrciZlcD12MV9pbnRlcm5uYWxfZ2lmX2J5X2lkJmN0PWc/fXnRObM8Q0RkOmR5nf/giphy.gif'
GIF_URL_ROTATION = 'https://media0.giphy.com/media/v1.Y2lkPTc5MGI3NjExdmx4azVxbGt4Mnk1cjMzZm5sMmp1YThteGJsMzcyYmhsdmFoczV0aSZlcD12MV9pbnRlcm5uYWxfZ2lmX2J5X2lkJmN0PWc/JpkZEKWY0s9QI4DGvF/giphy.gif'
SOUND_URL = "https://github.com/matheusmg0550247-collab/controle-bastao-eproc2/raw/refs/heads/main/doorbell-223669.mp3"


# --- 2. Fun√ß√£o Geradora do C√≥digo ---
def generate_app_code(consultores, emoji, webhook_relatorio, webhook_bastao, public_url):
    app_code_lines = [
        "import streamlit as st",
        "import pandas as pd",
        "import requests",
        "import time",
        "import json",
        "import os",
        "from datetime import datetime, timedelta",
        "from operator import itemgetter",
        "from streamlit_autorefresh import st_autorefresh",
        "",
        f"BASTAO_EMOJI = '{emoji}'",
        f"CONSULTORES = {consultores}",
        f"WEBHOOK_RELATORIO = '{webhook_relatorio}'",
        f"WEBHOOK_BASTAO = '{webhook_bastao}'",
        f"APP_URL = '{public_url}'",
        "LOG_FILE = 'status_log.json'",
        "STATE_FILE = 'app_state.json'",
        "STATUS_SAIDA_PRIORIDADE = ['Sa√≠da Tempor√°ria']",
        "STATUSES_DE_SAIDA = ['Atividade', 'Almo√ßo', 'Sa√≠da Tempor√°ria']",
        f"GIF_URL_WARNING = '{GIF_URL_WARNING}'",
        f"GIF_URL_ROTATION = '{GIF_URL_ROTATION}'",
        f"SOUND_URL = '{SOUND_URL}'",
        "",
        "# --- Fun√ß√µes de Persist√™ncia ---",
        "def date_serializer(obj):",
        "    if isinstance(obj, datetime): return obj.isoformat()",
        "    return str(obj)",
        "",
        "def save_state():",
        "    state_to_save = {",
        "        'status_texto': st.session_state.status_texto,",
        "        'bastao_queue': st.session_state.bastao_queue,",
        "        'bastao_start_time': st.session_state.bastao_start_time,",
        "        'current_status_starts': st.session_state.current_status_starts,",
        "        'report_last_run_date': st.session_state.report_last_run_date,",
        "        'bastao_counts': st.session_state.bastao_counts,",
        "        'priority_return_queue': st.session_state.priority_return_queue,",
        "        'rotation_gif_start_time': st.session_state.get('rotation_gif_start_time'),",
        "        'master_order': st.session_state.master_order,",
        "        # N√£o persistimos completed_this_cycle nem initial_cycle_members",
        "    }",
        "    try:",
        "        with open(STATE_FILE, 'w') as f: json.dump(state_to_save, f, indent=4, default=date_serializer)",
        "        print(f'*** Estado Salvo ***')",
        "    except Exception as e: print(f'Erro ao salvar estado: {e}')",
        "",
        "def load_state():",
        "    # ... (load_state como na vers√£o anterior, garantindo tipos corretos) ...",
        "    if not os.path.exists(STATE_FILE): return {}",
        "    try:",
        "        with open(STATE_FILE, 'r') as f: data = json.load(f)",
        "        for key in ['bastao_start_time', 'report_last_run_date', 'rotation_gif_start_time']:",
        "            if data.get(key) and isinstance(data[key], str):",
        "                try: data[key] = datetime.fromisoformat(data[key])",
        "                except ValueError: data[key] = None",
        "        if 'current_status_starts' in data and isinstance(data['current_status_starts'], dict):",
        "             temp_starts = {}",
        "             for c, ts in data['current_status_starts'].items():",
        "                 if ts and isinstance(ts, str):",
        "                     try: temp_starts[c] = datetime.fromisoformat(ts)",
        "                     except ValueError: temp_starts[c] = datetime.now()",
        "                 elif isinstance(ts, datetime): temp_starts[c] = ts",
        "                 else: temp_starts[c] = datetime.now()",
        "             data['current_status_starts'] = temp_starts",
        "        else: data['current_status_starts'] = {}",
        "        if 'master_order' not in data or not isinstance(data['master_order'], list): data['master_order'] = []",
        "        data.setdefault('status_texto', {})",
        "        data.setdefault('bastao_queue', [])",
        "        data.setdefault('bastao_counts', {})",
        "        data.setdefault('priority_return_queue', [])",
        "        return data",
        "    except Exception as e: print(f'Erro ao carregar estado: {e}. Resetando.'); return {}",

        "",
        "# --- Fun√ß√µes Auxiliares ---",
        "def send_chat_notification_internal(c, s): pass",
        "def play_sound_html(): return f'<audio autoplay=\"true\"><source src=\"{SOUND_URL}\" type=\"audio/mpeg\"></audio>'",
        "def load_logs(): return []",
        "def save_logs(l): pass",
        "",
        "def log_status_change(consultor, old_status, new_status, duration):",
        "    print(f'LOG: {consultor} de \"{old_status or '-'}\" para \"{new_status or '-'}\" ap√≥s {duration}')",
        "    if not isinstance(duration, timedelta): duration = timedelta(0)",
        "    st.session_state.current_status_starts[consultor] = datetime.now()",
        "",
        "def format_time_duration(duration):",
        "    if not isinstance(duration, timedelta): return '--:--:--'",
        "    s = int(duration.total_seconds()); h, s = divmod(s, 3600); m, s = divmod(s, 60)",
        "    return f'{h:02}:{m:02}:{s:02}'",
        "",
        "def send_daily_report(): pass",
        "",
        "# --- Inicializa√ß√£o ---",
        "def init_session_state():",
        "    persisted_state = load_state()",
        "    defaults = {",
        "        'status_texto': {nome: '' for nome in CONSULTORES}, 'bastao_queue': [],",
        "        'bastao_start_time': None, 'current_status_starts': {nome: datetime.now() for nome in CONSULTORES},",
        "        'report_last_run_date': datetime.min, 'bastao_counts': {nome: 0 for nome in CONSULTORES},",
        "        'priority_return_queue': [], 'rotation_gif_start_time': None,",
        "        'master_order': [],",
        "        # Estados n√£o persistentes:",
        "        'completed_this_cycle': set(), 'initial_cycle_members': set()",
        "    }",
        "    # Carrega ou define defaults",
        "    for key, default in defaults.items():",
        "        # Apenas carrega os persistentes, reseta os n√£o persistentes",
        "        if key in ['completed_this_cycle', 'initial_cycle_members']:",
        "             st.session_state[key] = default",
        "        else:",
        "             st.session_state.setdefault(key, persisted_state.get(key, default))",
        "",
        "    # Garante tipos corretos p√≥s-carregamento",
        "    if not isinstance(st.session_state.master_order, list): st.session_state.master_order = []",
        "    if not isinstance(st.session_state.bastao_queue, list): st.session_state.bastao_queue = []",
        "    if not isinstance(st.session_state.completed_this_cycle, set): st.session_state.completed_this_cycle = set()",
        "    if not isinstance(st.session_state.initial_cycle_members, set): st.session_state.initial_cycle_members = set()",
        "",
        "    # Limpa listas de consultores inv√°lidos",
        "    st.session_state.master_order = [c for c in st.session_state.master_order if c in CONSULTORES]",
        "    st.session_state.bastao_queue = [c for c in st.session_state.bastao_queue if c in CONSULTORES]",
        "",
        "    # Define estado inicial dos checkboxes e current_starts",
        "    available_people = set(st.session_state.bastao_queue) | st.session_state.completed_this_cycle",
        "    loaded_starts = persisted_state.get('current_status_starts', {})",
        "    for nome in CONSULTORES:",
        "        is_active = nome in available_people or bool(st.session_state.status_texto.get(nome))",
        "        st.session_state.setdefault(f'check_{nome}', is_active)",
        "        st.session_state.current_status_starts.setdefault(nome, loaded_starts.get(nome, datetime.now()))",
        "",
        "    # Verifica se o ciclo precisa ser iniciado/resetado na carga",
        "    if not st.session_state.initial_cycle_members:",
        "         print('!!! Iniciando ciclo na carga !!!')",
        "         # Recria a fila ativa com todos dispon√≠veis na ordem mestre",
        "         st.session_state.bastao_queue = [c for c in st.session_state.master_order if st.session_state.get(f'check_{c}')]",
        "         # Adiciona novos dispon√≠veis que n√£o estavam na master order ainda",
        "         for c in CONSULTORES:",
        "              if st.session_state.get(f'check_{c}') and c not in st.session_state.bastao_queue:",
        "                  st.session_state.bastao_queue.append(c)",
        "                  if c not in st.session_state.master_order: st.session_state.master_order.append(c)",
        "         st.session_state.initial_cycle_members = set(st.session_state.bastao_queue)",
        "         st.session_state.completed_this_cycle = set()",
        "         print(f' Fila Ativa P√≥s-Init-Reset: {st.session_state.bastao_queue}')",
        "         print(f' Initial Members P√≥s-Init-Reset: {st.session_state.initial_cycle_members}')",
        "",
        "    print('--- Estado Inicializado ---')",
        "    # ... (prints de debug como antes) ...",
        "",
        "# --- L√≥gica de Ciclo ---",
        "def check_cycle_reset():",
        "    initial_members = st.session_state.initial_cycle_members",
        "    completed = st.session_state.completed_this_cycle",
        "    # Quem dos membros iniciais AINDA est√° dispon√≠vel?",
        "    initial_still_available = {c for c in initial_members if st.session_state.get(f'check_{c}')}",
        "    print(f'CHECK RESET: Initial Available: {initial_still_available}, Completed: {completed}')",
        "    if initial_still_available and initial_still_available.issubset(completed):",
        "        print('--- RESETANDO CICLO ---')",
        "        st.session_state.completed_this_cycle = set()",
        "        # Recria fila ativa com todos dispon√≠veis na ordem mestre",
        "        st.session_state.bastao_queue = [c for c in st.session_state.master_order if st.session_state.get(f'check_{c}')]",
        "        # Adiciona novos dispon√≠veis que n√£o estavam na master",
        "        for c in CONSULTORES:",
        "             if st.session_state.get(f'check_{c}') and c not in st.session_state.bastao_queue:",
        "                 st.session_state.bastao_queue.append(c)",
        "                 if c not in st.session_state.master_order: st.session_state.master_order.append(c)", # Garante master order atualizada
        "        st.session_state.initial_cycle_members = set(st.session_state.bastao_queue)",
        "        print(f'Nova Fila P√≥s-Reset: {st.session_state.bastao_queue}')",
        "        print(f'Novos Initial Members: {st.session_state.initial_cycle_members}')",
        "        return True",
        "    return False",
        "",
        "def check_and_assume_baton():",
        "    print('--- CHECK ASSUME BATON ---')",
        "    queue = st.session_state.bastao_queue",
        "    completed = st.session_state.completed_this_cycle",
        "    current_holder_status = next((c for c, s in st.session_state.status_texto.items() if s == 'Bast√£o'), None)",
        "    # Pr√≥ximo √© o primeiro na fila ATIVA que N√ÉO completou",
        "    next_holder = next((c for c in queue if c not in completed and st.session_state.get(f'check_{c}')), None)",
        "    print(f'Queue: {queue}, Completed: {completed}, Next: {next_holder}, Current: {current_holder_status}')",
        "",
        "    if next_holder == current_holder_status: print('Sem mudan√ßas.'); return False",
        "",
        "    changed = False",
        "    # Clear old holder",
        "    if current_holder_status and current_holder_status != next_holder:",
        "        print(f'Limpando bast√£o de {current_holder_status}')",
        "        duration = datetime.now() - st.session_state.current_status_starts.get(current_holder_status, datetime.now())",
        "        log_status_change(current_holder_status, 'Bast√£o', '', duration)",
        "        st.session_state.status_texto[current_holder_status] = ''",
        "        changed = True",
        "",
        "    # Assign new holder",
        "    if next_holder:",
        "        print(f'Atribuindo bast√£o para {next_holder}')",
        "        old_status = st.session_state.status_texto.get(next_holder, '')",
        "        duration = datetime.now() - st.session_state.current_status_starts.get(next_holder, datetime.now())",
        "        log_status_change(next_holder, old_status, 'Bast√£o', duration)",
        "        st.session_state.status_texto[next_holder] = 'Bast√£o'",
        "        st.session_state.bastao_start_time = datetime.now()",
        "        if current_holder_status != next_holder: st.session_state.play_sound = True",
        "        changed = True",
        "    elif not next_holder:", # No eligible holder
        "         if current_holder_status: # Clear baton if someone had it",
        "              print(f'Ningu√©m eleg√≠vel, limpando bast√£o de {current_holder_status}')",
        "              duration = datetime.now() - st.session_state.current_status_starts.get(current_holder_status, datetime.now())",
        "              log_status_change(current_holder_status, 'Bast√£o', '', duration)",
        "              st.session_state.status_texto[current_holder_status] = ''",
        "              changed = True",
        "         if st.session_state.bastao_start_time is not None: changed = True",
        "         st.session_state.bastao_start_time = None",
        "",
        "    if changed: save_state()",
        "    return changed",
        "",
        "# --- Callbacks ---",
        "def update_queue(consultor):",
        "    print(f'UPDATE QUEUE: {consultor}')",
        "    st.session_state.gif_warning = False; st.session_state.rotation_gif_start_time = None",
        "    is_checked = st.session_state.get(f'check_{consultor}')",
        "    old_status = st.session_state.status_texto.get(consultor, '')",
        "    duration = datetime.now() - st.session_state.current_status_starts.get(consultor, datetime.now())",
        "    was_holder = consultor == next((c for c, s in st.session_state.status_texto.items() if s == 'Bast√£o'), None)",
        "",
        "    if is_checked:",
        "        log_status_change(consultor, old_status or 'Indispon√≠vel', '', duration)",
        "        st.session_state.status_texto[consultor] = ''",
        "        if consultor not in st.session_state.master_order: st.session_state.master_order.append(consultor)",
        "        if consultor not in st.session_state.bastao_queue: st.session_state.bastao_queue.append(consultor)",
        "        # Se o ciclo j√° come√ßou, ele n√£o entra no initial_members agora",
        "        if not st.session_state.initial_cycle_members: # Se ciclo n√£o come√ßou (fila estava vazia?)",
        "             st.session_state.initial_cycle_members.add(consultor)",
        "    else:",
        "        log_status_change(consultor, old_status or ('Bast√£o' if was_holder else 'Dispon√≠vel'), 'Indispon√≠vel', duration)",
        "        st.session_state.status_texto[consultor] = '' # Clear specific status too",
        "        if consultor in st.session_state.bastao_queue: st.session_state.bastao_queue.remove(consultor)",
        "        st.session_state.completed_this_cycle.discard(consultor) # Sai do ciclo atual",
        "        # N√£o remove de initial_cycle_members",
        "",
        "    print(f'... Fila Ativa: {st.session_state.bastao_queue}, Master: {st.session_state.master_order}, Completed: {st.session_state.completed_this_cycle}, Initial: {st.session_state.initial_cycle_members}')",
        "    reset = check_cycle_reset()",
        "    baton = check_and_assume_baton()",
        "    if not baton: save_state()",
        "    st.rerun()",
        "",
        "def finish_turn_action(): # Fun√ß√£o unificada para Passar e Pular (agora id√™nticos)",
        "    print('FINISH TURN ACTION (Passar/Pular)')",
        "    selected = st.session_state.consultor_selectbox",
        "    st.session_state.gif_warning = False; st.session_state.rotation_gif_start_time = None",
        "    if not selected or selected == 'Selecione um nome': st.warning('Selecione.'); return",
        "    queue = st.session_state.bastao_queue",
        "    current_holder_status = next((c for c, s in st.session_state.status_texto.items() if s == 'Bast√£o'), None)",
        "    if selected != current_holder_status:", # S√≥ o portador atual pode finalizar o turno
        "        st.session_state.gif_warning = True; st.rerun(); return",
        "",
        "    holder = selected # Sabemos que √© o portador",
        "    # Marca como completo",
        "    st.session_state.completed_this_cycle.add(holder)",
        "    # Remove da fila ativa (N√ÉO volta pro fim)",
        "    if holder in st.session_state.bastao_queue: st.session_state.bastao_queue.remove(holder)",
        "",
        "    duration = datetime.now() - (st.session_state.bastao_start_time or datetime.now())",
        "    log_status_change(holder, 'Bast√£o', 'Pulou', duration) # Log como 'Pulou'",
        "    st.session_state.status_texto[holder] = '' # Limpa status",
        "    st.session_state.bastao_counts[holder] = st.session_state.bastao_counts.get(holder, 0) + 1",
        "    st.session_state.play_sound = True",
        "    st.session_state.rotation_gif_start_time = datetime.now()",
        "",
        "    print(f'... Fila Ativa: {st.session_state.bastao_queue}, Master: {st.session_state.master_order}, Completed: {st.session_state.completed_this_cycle}, Initial: {st.session_state.initial_cycle_members}')",
        "    reset = check_cycle_reset()",
        "    check_and_assume_baton()", # Acha o pr√≥ximo ou reseta
        "    # Save state happens in check_and_assume",
        "    st.rerun()",
        "",
        "def update_status(status_text, change_to_available): # Marca como Indispon√≠vel + Status",
        "    print(f'UPDATE STATUS: {status_text}')",
        "    selected = st.session_state.consultor_selectbox",
        "    st.session_state.gif_warning = False; st.session_state.rotation_gif_start_time = None",
        "    if not selected or selected == 'Selecione um nome': st.warning('Selecione.'); return",
        "",
        "    st.session_state[f'check_{selected}'] = False # Marca indispon√≠vel",
        "    was_holder = next((True for c, s in st.session_state.status_texto.items() if s == 'Bast√£o' and c == selected), False)",
        "    old_status = st.session_state.status_texto.get(selected, '') or ('Bast√£o' if was_holder else 'Dispon√≠vel')",
        "    duration = datetime.now() - st.session_state.current_status_starts.get(selected, datetime.now())",
        "    log_status_change(selected, old_status, status_text, duration)",
        "    st.session_state.status_texto[selected] = status_text",
        "",
        "    if selected in st.session_state.bastao_queue: st.session_state.bastao_queue.remove(selected)",
        "    st.session_state.completed_this_cycle.discard(selected)",
        "    # N√£o remove de initial_cycle_members",
        "",
        "    if status_text == 'Sa√≠da Tempor√°ria': # Logic for priority queue",
        "        if selected not in st.session_state.priority_return_queue: st.session_state.priority_return_queue.append(selected)",
        "    elif selected in st.session_state.priority_return_queue: st.session_state.priority_return_queue.remove(selected)",
        "",
        "    print(f'... Fila Ativa: {st.session_state.bastao_queue}, Master: {st.session_state.master_order}, Completed: {st.session_state.completed_this_cycle}, Initial: {st.session_state.initial_cycle_members}')",
        "    reset = check_cycle_reset()",
        "    baton = False",
        "    if was_holder or reset:",
        "        baton = check_and_assume_baton()",
        "    if not baton: save_state()",
        "    st.rerun()",
        "",
        "def manual_rerun():",
        "    print('MANUAL RERUN')",
        "    st.session_state.gif_warning = False; st.session_state.rotation_gif_start_time = None",
        "    st.rerun()",
        "",
        "# --- Execu√ß√£o Principal ---",
        'st.set_page_config(page_title="Controle Bast√£o Cesupe", layout="wide")',
        "st.markdown('<style>div.stAlert { display: none !important; }</style>', unsafe_allow_html=True)",
        "init_session_state()",
        "",
        "st.title(f'Controle Bast√£o Cesupe {BASTAO_EMOJI}')",
        'st.markdown("<hr style=\\"border: 1px solid #E75480;\\">", unsafe_allow_html=True)',
        "",
        "# Auto Refresh & Timed Elements",
        "gif_start_time = st.session_state.get('rotation_gif_start_time')",
        "show_gif = False; refresh_interval = 30000",
        "if gif_start_time:",
        "    try:",
        "        elapsed = (datetime.now() - gif_start_time).total_seconds()",
        "        if elapsed < 20: show_gif = True; refresh_interval = 5000",
        "        else: st.session_state.rotation_gif_start_time = None",
        "    except: st.session_state.rotation_gif_start_time = None",
        "st_autorefresh(interval=refresh_interval, key='auto_rerun_key')",
        "if st.session_state.get('play_sound', False):",
        "    st.components.v1.html(play_sound_html(), height=0, width=0); st.session_state.play_sound = False",
        "if show_gif: st.image(GIF_URL_ROTATION, width=200, caption='Turno Finalizado!')", # Changed caption
        "if st.session_state.get('gif_warning', False):",
        "    st.error('üö´ A√ß√£o inv√°lida! Apenas o portador atual pode usar üéØ Bast√£o ou ‚è≠Ô∏è Pular.'); st.image(GIF_URL_WARNING, width=150)",
        "",
        "# Garantir Assun√ß√£o Inicial/P√≥s-Reset",
        "holder_exists = any(s == 'Bast√£o' for s in st.session_state.status_texto.values())",
        "if not holder_exists and st.session_state.bastao_queue and any(c not in st.session_state.completed_this_cycle for c in st.session_state.bastao_queue):", # Ensure someone eligible exists
        "    print('!!! FOR√áANDO CHECK ASSUME BATON NO RENDER !!!')",
        "    if check_and_assume_baton(): st.rerun()",
        "",
        "# Layout",
        'col_principal, col_disponibilidade = st.columns([1.5, 1])',
        "active_queue = st.session_state.bastao_queue",
        "master = st.session_state.master_order",
        "completed = st.session_state.completed_this_cycle",
        "responsavel = next((c for c, s in st.session_state.status_texto.items() if s == 'Bast√£o'), None)",
        "# Pr√≥ximo √© o primeiro na fila ativa que N√ÉO completou",
        "proximo = next((c for c in active_queue if c not in completed and st.session_state.get(f'check_{c}')), None)",
        "# Restante: todos na fila ativa depois do pr√≥ximo que n√£o completaram",
        "proximo_index = active_queue.index(proximo) if proximo in active_queue else -1",
        "restante = [c for i, c in enumerate(active_queue) if i > proximo_index and c not in completed and st.session_state.get(f'check_{c}')] if proximo_index != -1 else []",
        "",
        "with col_principal:",
        '    st.header("Respons√°vel pelo Bast√£o")',
        "    _, col_time = st.columns([0.25, 0.75])",
        "    duration = timedelta()",
        "    if responsavel and st.session_state.bastao_start_time:",
        "        try: duration = datetime.now() - st.session_state.bastao_start_time",
        "        except: pass",
        "    col_time.markdown(f'#### üïí Tempo: **{format_time_duration(duration)}**')",
        "    if responsavel:",
        "        st.markdown(f'<span style=\"background-color: #E75480; color: white; padding: 5px 10px; border-radius: 5px; font-size: 2em; font-weight: bold;\">üî• {responsavel}</span>', unsafe_allow_html=True)",
        "    else: st.markdown('## (Ningu√©m com o bast√£o)')",
        '    st.markdown("###")',
        '    st.header("Pr√≥ximos da Fila (Eleg√≠veis)")',
        "    if proximo: st.markdown(f'### 1¬∫: **{proximo}**')",
        "    if restante: st.markdown(f'#### 2¬∫ em diante: {', '.join(restante)}')",
        "    if not proximo:",
        "        if responsavel: st.markdown('*Apenas o respons√°vel na fila ativa.*')",
        "        else: st.markdown('*Ningu√©m eleg√≠vel na fila ativa.*')",
        "    if completed:",
        "        st.markdown(f'<br><span style=\"color:grey;\">‚úîÔ∏è Completou/Pulou nesta volta:</span> {', '.join(sorted(list(completed)))}', unsafe_allow_html=True)",
        '    st.markdown("###")',
        '    st.header("**Consultor**")',
        "    st.selectbox('Selecione:', options=['Selecione um nome'] + CONSULTORES, key='consultor_selectbox', label_visibility='collapsed')",
        '    st.markdown("#### "); st.markdown("**A√ß√µes:**")',
        '    c1, c2, c3, c4, c5 = st.columns(5)',
        "    # Bot√µes 'Bast√£o' e 'Pular' agora chamam a mesma fun√ß√£o",
        "    c1.button('üéØ Bast√£o', on_click=finish_turn_action, use_container_width=True, help='Finaliza seu turno (marca como \"Pulou\") e passa para o pr√≥ximo. Apenas o respons√°vel atual.')",
        "    c2.button('‚è≠Ô∏è Pular', on_click=finish_turn_action, use_container_width=True, help='Finaliza seu turno (marca como \"Pulou\") e passa para o pr√≥ximo. Apenas o respons√°vel atual.')",
        "    c3.button('‚úèÔ∏è Atividade', on_click=update_status, args=('Atividade', False,), use_container_width=True)",
        "    c4.button('üçΩÔ∏è Almo√ßo', on_click=update_status, args=('Almo√ßo', False,), use_container_width=True)",
        "    c5.button('üö∂ Sa√≠da', on_click=update_status, args=('Sa√≠da Tempor√°ria', False,), use_container_width=True)",
        '    st.markdown("####")',
        "    st.button('üîÑ Atualizar (Manual)', on_click=manual_rerun, use_container_width=True)",
        '    st.markdown("---")',
        "",
        "with col_disponibilidade:",
        "    st.header('Status dos Consultores')",
        "    st.markdown('Marque/Desmarque para entrar/sair.')",
        "    ui_lists = {'fila': [], 'atividade': [], 'almoco': [], 'saida': [], 'indisponivel': []}",
        "    for nome in CONSULTORES:",
        "        is_checked = st.session_state.get(f'check_{nome}', False)",
        "        status = st.session_state.status_texto.get(nome, '')",
        "        if is_checked: ui_lists['fila'].append(nome)",
        "        elif status == 'Atividade': ui_lists['atividade'].append(nome)",
        "        elif status == 'Almo√ßo': ui_lists['almoco'].append(nome)",
        "        elif status == 'Sa√≠da Tempor√°ria': ui_lists['saida'].append(nome)",
        "        else: ui_lists['indisponivel'].append(nome)",
        "",
        "    st.subheader(f'‚úÖ Na Fila ({len(ui_lists['fila'])})')",
        "    master_ordered_fila = [c for c in master if c in ui_lists['fila']]",
        "    newly_available = [c for c in ui_lists['fila'] if c not in master]",
        "    combined_fila_render_order = master_ordered_fila + newly_available",
        "    if not combined_fila_render_order: st.markdown('_Ningu√©m dispon√≠vel._')",
        "    else:",
        "        for nome in combined_fila_render_order:",
        "            col_nome, col_check = st.columns([0.8, 0.2])",
        "            key = f'check_{nome}'",
        "            col_check.checkbox(' ', key=key, on_click=update_queue, args=(nome,), label_visibility='collapsed')", # Changed to onClick
        "            if nome == responsavel:",
        "                display = f'<span style=\"background-color: #E75480; color: white; padding: 2px 6px; border-radius: 5px; font-weight: bold;\">üî• {nome}</span>'",
        "            elif nome in completed:", # Usa 'completed' para 'Pulou' visualmente
        "                display = f'**{nome}** :grey-background[‚úîÔ∏è Turno Conclu√≠do]'", # Alterado para cinza/conclu√≠do
        "            elif nome in active_queue:",
        "                 display = f'**{nome}** :blue-background[Aguardando]'", # Alterado para Aguardando
        "            else: display = f'**{nome}** :green-background[Dispon√≠vel]'", # Novo entrante ou p√≥s-reset antes do bast√£o chegar
        "            col_nome.markdown(display, unsafe_allow_html=True)",
        "    st.markdown('---')",
        "",
        "    def render_section(title, icon, names, tag_color):",
        "        st.subheader(f'{icon} {title} ({len(names)})')",
        "        if not names: st.markdown(f'_Ningu√©m em {title.lower()}._')",
        "        else:",
        "            for nome in sorted(names):",
        "                col_nome, col_check = st.columns([0.8, 0.2])",
        "                key = f'check_{nome}'",
        "                # Use onClick for immediate feedback if needed, else onChange is fine",
        "                col_check.checkbox(' ', key=key, on_click=update_queue, args=(nome,), label_visibility='collapsed')",
        "                col_nome.markdown(f'**{nome}** :{tag_color}-background[{title}]', unsafe_allow_html=True)",
        "        st.markdown('---')",
        "    render_section('Atividade', '‚úèÔ∏è', ui_lists['atividade'], 'yellow')",
        "    render_section('Almo√ßo', 'üçΩÔ∏è', ui_lists['almoco'], 'blue')",
        "    render_section('Sa√≠da', 'üö∂', ui_lists['saida'], 'red')",
        "    render_section('Indispon√≠vel', '‚ùå', ui_lists['indisponivel'], 'grey')",
        "",
        "    if datetime.now().hour >= 20 and datetime.now().date() > (st.session_state.report_last_run_date.date() if isinstance(st.session_state.report_last_run_date, datetime) else datetime.min.date()):",
        "        send_daily_report()",
        "",
        "print('--- FIM DO RENDER ---')",
    ]
    return "\\n".join(line for line in app_code_lines if line) # Ensure no exactly empty lines break exec


# --- 3. Execu√ß√£o Final ---
app_code_to_exec = generate_app_code(
    CONSULTORES, BASTAO_EMOJI, GOOGLE_CHAT_WEBHOOK_RELATORIO, CHAT_WEBHOOK_BASTAO, APP_URL_CLOUD
)
exec(app_code_to_exec)
